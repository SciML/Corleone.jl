{
  "hash": "09f5e1b012bd95cafbb8bcfa5d60ab73",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: Linear quadratic regulator \nauthor: Carl Julius Martensen\ndate: last-modified\ncategories: \n  - ODE\ndescription: This example introduces Corleone.\nengines: ['julia']\njulia:\n  exeflags: [\"--project=..\"]\nformat: \n  html: default\n  ipynb: default\n  mediawiki: default\nformat-links: \n  - text: Julia \n    href: ./code/lqr.jl \n    icon: file-code \n  - ipynb\n---\n\n\nLet‚Äôs start by modeling the [linear quadratic regulator](https://en.wikipedia.org/wiki/Linear‚Äìquadratic_regulator). This example is one of the simplest optimal control problems. Lets assume we want to It reads as\n\n\\begin{align}\n\\min_u & \\int_0^T w_1 (x - x_f)^2 + w_2 u^2 dt \\\\\n\\text{s.t.} \\quad & \\dot{x} = a x + b u\n\\end{align}\n\nFirst, we load the necessary packages to model the problem.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Corleone\nusing Corleone.ModelingToolkit\nusing Corleone.ModelingToolkit: t_nounits as t, D_nounits as D\n```\n:::\n\n\n\nWe use ModelingToolkit.jl to model the optimal control problem.\n\n::: {.callout-note}\n  We use ModelingToolkits `@mtkmodel` here. The reason for this is that we do not have any constraints on the dynamic states. See other examples on how to use a custom function to generate models or have a look at the (ModelingToolkit.jl documentation.)\n:::\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\n@mtkmodel LQR begin \n    @description \"Linear quadratic regulator\"\n    @variables begin\n        x(t)=1.0, [description = \"State variable\", tunable = false]\n        u(t)=0.0, [description = \"Control variable\", input = true]\n    end \n    @parameters begin \n        a=-1.0, [description = \"Decay\", tunable = false]\n        b=1.0, [description = \"Input scale\", tunable = false]\n    end \n    @equations begin\n        D(x) ~ a * x + b * u\n    end \n    @costs begin \n        Symbolics.Integral(t in (0., 10.)).(10.0*(x-3.0)^2 + 0.1*u^2)\n    end\n    @consolidate begin\n        (system_costs...) -> first(system_costs)[1]\n    end\nend;\n```\n:::\n\n\n\n\n## Modeling explained step by step\n\nAlright. Lets break down each part of the model.\n\nFirst, we add a description of the model. This is useful for collaborateurs, different usecases and future you.\n\n```julia\n    @description \"Linear quadratic regulator\"\n```\n\nNext, we define the variables *x*(*t*),‚ÄÜ*u*(*t*) of the model. As given in the problem definition above, this defines or state and our control signal respectively.\n\n```julia\n    @variables begin\n        x(t)=1.0, [description = \"State variable\", tunable = false]\n        u(t)=0.0, [description = \"Control variable\", input = true]\n    end \n```\n\nLets break this down line by line.\n\n```julia\nx(t)=1.0, [description = \"State variable\", tunable = false]\n```\n\nDefines a variable which **depends on *t*** represented by the symbol `x`. It has a default value of `1.0`, which corresponds to the intial value of the variable. Similar to the full system, we can add a description or other (metadata) to the variable using the square brackets. Note that we explicitly set `tunable=false`. This indicates later on that the initial condition is **fixed**.\n\n```julia\nu(t)=0.0, [description = \"Control variable\", input = true]\n```\n\nSimilar to the definition of `x` we define a variable `u` which depends on time. Note that we set `input=true` to indicate that this is a control variable.\n\nTo define the parameters of the system, we can use the `@parameters` macro. Similar to above, we create two symbolic variables which are **independent of *t*** and represent constant values - indicated by `tunable = false`.\n\n```julia\n    @parameters begin \n        a=-1.0, [description = \"Decay\", tunable = false]\n        b=1.0, [description = \"Input scale\", tunable = false]\n    end \n```\n\nTo model the system of differential equations, we simply write it down!\n\n```julia\n    @equations begin\n        D(x) ~ a * x + b * u\n    end \n```\n\nSo far this defines the corresponding ODE system without any additional information. However, we want to solve an optimal control problem!\n\nLuckily, ModelingToolkit - starting from version 10.0 - supports to model general systems. Hence, we can simply add `costs` and `constraints` to our system definition.\n\nOur goal is to minimize an integrated expression over time. Given that Symbolics defines an `Integral` operator, we can simply write\n\n```julia\n    @costs begin \n        Symbolics.Integral(t in (0., 10.)).(10.0*(x-3.0)^2 + 0.1*u^2)\n    end\n```\n\nWhich internally defines a `Vector` of costs. To combine this vector and possible subsystems in a meaningful way, we must provide a `consolidate` function.\n\n``` julia\n    @consolidate begin\n        (system_costs...) -> first(system_costs)[1]\n    end\n```\n\nWhich just takes in several system costs and returns the first vector entry of the first system.\n\n## Instantiate the model\n\nNext, we generate an instance of the model.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nlqr_model = LQR(; name = :LQR)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nModel LQR: Linear quadratic regulator\nEquations (1):\n  1 standard: see equations(LQR)\nUnknowns (2): see unknowns(LQR)\n  x(t) [defaults to 1.0]: State variable\n  u(t) [defaults to 0.0]: Control variable\nParameters (2): see parameters(LQR)\n  a [defaults to -1.0]: Decay\n  b [defaults to 1.0]: Input scale\n```\n:::\n:::\n\n\n\nNote that every model needs a `name` in the form of a symbol.\n\nWe now have symbolic instance of our model. However, we still need to define our inputs `u` properly. To do this, we first extract the corresponding variable from the model **without namespacing**.\n\n::: {.callout-note}\nRight now, this is required from Corleone.jl to find the corresponding variable. In the future, we plan to make this easier and support namespaced variables.\n:::\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nu = ModelingToolkit.getvar(lqr_model, :u, namespace = false)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nu(t)\n```\n:::\n:::\n\n\n\nNext, we use this variable to define a piecewise constant function for *u*.\nThere are different formulations which can be employed, but in general we recommend using the `DirectControlCallback`.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\ncontrol = DirectControlCallback(Num(u) => (; timepoints = collect(0.0:0.5:9.5)));\n```\n:::\n\n\n\nThis formulation adds callbacks at the provided `timepoints`.\n\nFinally we can combine our model, the control method, a shooting grid and initialization scheme into our problem.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nproblem = OCProblemBuilder(lqr_model, control, ShootingGrid([0.,]))\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmin Integral(t, 0.0 .. 10.0)(0.1(u(t)^2) + 10.0((-3.0 + x(t))^2))\n\ns.t.\n\nDynamics LQR\n     Differential(t)(x(t)) ~ a*x(t) + b*u(t)\n```\n:::\n:::\n\n\n\n## Expanding the model\n\nThe problem itsself is not useful for us right now. To transform the initial representation into a tractable symbolic representation, we simply call the problem.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nexpandedproblem = problem()\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nmin ùïÉ‚ÇÅ(10.0)\n\ns.t.\n\nDynamics LQR\n     Differential(t)(ùïÉ‚ÇÅ(t)) ~ 0.1(u(t)^2) + 10.0((-3.0 + x(t))^2)\n     Differential(t)(x(t)) ~ a*x(t) + b*u(t)\n     Differential(t)(u(t)) ~ -0.0\n```\n:::\n:::\n\n\n\nThis call transformed the system into a different, but equivalent formulation. It added the control definitions and moved integrals around.\n\n## Optimize\n\nNow that our symbolic system is ready, lets optimize it!\n\nSimilar to using ModelingToolkit, we will now rely on Optimization jl to solve the corresponding optimal control problem. Lets start by loading the packages:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Optimization, OptimizationMOI, Ipopt\nusing OrdinaryDiffEqTsit5, SciMLSensitivity\n```\n:::\n\n\n\nAnd transform our symbolic problem into an optimization problem.\n\nTo do this, we need additional information on how to compute the necessary derivatives of the objective function and constraints, and solve the differential equations. We will use ForwardDiff.jl to compute derivatives - given that our problem is relatively small - and `Tsit5` to integrate our system of differential equations.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\noptimization_problem = OptimizationProblem{true}(expandedproblem, AutoForwardDiff(), Tsit5())\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nOptimizationProblem. In-place: true\nu0: 21-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n ‚ãÆ\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n```\n:::\n:::\n\n\n\nFinally, we solve the resulting problem using Ipopt and plot the results.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\noptimization_solution = solve(optimization_problem, Ipopt.Optimizer(),)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n******************************************************************************\nThis program contains Ipopt, a library for large-scale nonlinear optimization.\n Ipopt is released as open source code under the Eclipse Public License (EPL).\n         For more information visit https://github.com/coin-or/Ipopt\n******************************************************************************\n\nThis is Ipopt version 3.14.17, running with linear solver MUMPS 5.8.0.\n\nNumber of nonzeros in equality constraint Jacobian...:        0\nNumber of nonzeros in inequality constraint Jacobian.:        0\nNumber of nonzeros in Lagrangian Hessian.............:      210\n\nTotal number of variables............................:       20\n                     variables with only lower bounds:        0\n                variables with lower and upper bounds:        0\n                     variables with only upper bounds:        0\nTotal number of equality constraints.................:        0\nTotal number of inequality constraints...............:        0\n        inequality constraints with only lower bounds:        0\n   inequality constraints with lower and upper bounds:        0\n        inequality constraints with only upper bounds:        0\n\niter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls\n   0  8.4500271e+02 0.00e+00 2.98e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0\n   1  1.5772524e+01 0.00e+00 1.59e-04  -1.0 6.87e+00    -  1.00e+00 1.00e+00f  1\n   2  1.5772524e+01 0.00e+00 2.18e-07  -5.7 4.38e-04    -  1.00e+00 1.00e+00f  1\n   3  1.5772524e+01 0.00e+00 4.07e-10  -8.6 6.78e-07    -  1.00e+00 1.00e+00f  1\n\nNumber of Iterations....: 3\n\n                                   (scaled)                 (unscaled)\nObjective...............:   1.5772524036872642e+01    1.5772524036872642e+01\nDual infeasibility......:   4.0705994130973977e-10    4.0705994130973977e-10\nConstraint violation....:   0.0000000000000000e+00    0.0000000000000000e+00\nVariable bound violation:   0.0000000000000000e+00    0.0000000000000000e+00\nComplementarity.........:   0.0000000000000000e+00    0.0000000000000000e+00\nOverall NLP error.......:   4.0705994130973977e-10    4.0705994130973977e-10\n\n\nNumber of objective function evaluations             = 4\nNumber of objective gradient evaluations             = 4\nNumber of equality constraint evaluations            = 0\nNumber of inequality constraint evaluations          = 0\nNumber of equality constraint Jacobian evaluations   = 0\nNumber of inequality constraint Jacobian evaluations = 0\nNumber of Lagrangian Hessian evaluations             = 3\nTotal seconds in IPOPT                               = 14.951\n\nEXIT: Optimal Solution Found.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nretcode: Success\nu: 21-element Vector{Float64}:\n 1.0\n 6.865341837123803\n 2.303020511034252\n 3.084624489682982\n 2.9506996290744407\n 2.973658328965578\n 2.969720781097132\n 2.970395856955674\n 2.9702800858740277\n 2.9702999379278796\n ‚ãÆ\n 2.9702967089587893\n 2.970298802173118\n 2.970286737658208\n 2.9703568817904946\n 2.969948951800308\n 2.9723213263356705\n 2.9585244447063057\n 3.0387621686432014\n 2.5721283077786925\n```\n:::\n:::\n\n\n\n::: {.cell renderings='[\"light\",\"dark\"]' execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing CairoMakie\n\nfunction result_plot_lqr(problem, u)\n  sol = problem.f.f.predictor(u, saveat = 0.01);\n  f = Figure(title = \"LQR Results\")\n  ax = Axis(f[1,1], ylabel = \"x(t)\")\n  plot!(sol[1], idxs = [:x])\n  ax2 = Axis(f[2, 1], ylabel = \"u(t)\") \n  plot!(sol[1], idxs = [:u])\n  ax3 = Axis(f[3,1], ylabel = \"Running costs\", xlabel = \"t\")\n  plot!(sol[1], idxs = [1])\n  linkxaxes!(ax, ax2, ax3)\n  return f\nend\n# We want two outputs for the light and dark rendering. Hence we use display\nupdate_theme!(theme_light());\nf_light = result_plot_lqr(optimization_problem, optimization_solution.u)\ndisplay(f_light)\nupdate_theme!(theme_dark());\nf_dark = result_plot_lqr(optimization_problem, optimization_solution.u)\n```\n\n::: {.cell-output .cell-output-display}\n![](lqr_files/figure-mediawiki/cell-12-output-1.png){width=672 height=480}\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n![](lqr_files/figure-mediawiki/cell-12-output-2.png){width=672 height=480}\n:::\n:::\n\n\n\n## Appendix\n\n### Reproducability\n\nThis document was rendered using Quarto CLI {{< version >}}.\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\nusing Pkg\n\nversioninfo()\n\nPkg.status()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJulia Version 1.10.10\nCommit 95f30e51f41 (2025-06-27 09:51 UTC)\nBuild Info:\n  Official https://julialang.org/ release\nPlatform Info:\n  OS: macOS (arm64-apple-darwin24.0.0)\n  CPU: 11 √ó Apple M3 Pro\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-15.0.7 (ORCJIT, apple-m1)\nThreads: 1 default, 0 interactive, 1 GC (on 5 virtual cores)\nEnvironment:\n  JULIA_LOAD_PATH = @:@stdlib\nStatus `~/Projects/Corleone/docs/Project.toml`\n‚åÉ [13f3f980] CairoMakie v0.13.10\n  [2751e0db] Corleone v1.0.0-DEV `..`\n  [ffbed154] DocStringExtensions v0.9.5\n  [b6b21f68] Ipopt v1.10.6\n  [961ee093] ModelingToolkit v10.10.0\n  [7f7a1694] Optimization v4.4.0\n  [fd9f6733] OptimizationMOI v0.5.5\n  [1dea7af3] OrdinaryDiffEq v6.99.0\n  [b1df2697] OrdinaryDiffEqTsit5 v1.1.0\n‚åÉ [1ed8b502] SciMLSensitivity v7.87.1\n  [3a884ed6] UnPack v1.0.2\nInfo Packages marked with ‚åÉ have new versions available and may be upgradable.\n```\n:::\n:::\n\n\n\n### Doctests \n\nAdditional tests which are exported:\n\n```julia\n@test isapprox(optimization_solution.u, [1.0, 6.865341837123803, 2.303020511034252, 3.084624489682982, 2.9506996290744407, 2.973658328965578, 2.969720781097132, 2.970395856955674, 2.9702800858740277, 2.9702999379278796, 2.9702965162164032, 2.9702971776852873, 2.9702967089587893, 2.970298802173118, 2.970286737658208, 2.9703568817904946, 2.969948951800308, 2.9723213263356705, 2.9585244447063057, 3.0387621686432014, 2.5721283077786925])\n@test SciMLBase.ReturnCode.Success == optimization_solution.retcode\n@test isapprox(optimization_solution.objective, 1.5772524e+01)\n@test optimization_solution.stats.iterations == 3 \nfinal_system = optimization_problem.f.f.predictor.problem.f.sys\n@test ModelingToolkit.iscomplete(final_system)\n@test Corleone.get_shootingpoints(final_system) == [0.0]\nxshoot = Corleone.get_shootingpoint_variables(final_system)\n@test length(xshoot) == 1 \n@test length(only(xshoot)) == 1\n@test isequal(collect.(xshoot), collect.([final_system.x‚Çõ‚Çú]))\nucontrol =  Corleone.get_localcontrols(final_system)\n@test length(ucontrol) == 1 \n@test length(only(ucontrol)) == 20\n@test isequal(collect.(ucontrol), collect.([final_system.u·µ¢]))\n```\n\n",
    "supporting": [
      "lqr_files/figure-mediawiki"
    ],
    "filters": []
  }
}