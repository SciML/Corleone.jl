---
title: Bryson Denham 
author: Carl Julius Martensen
date: last-modified
categories: 
  - ODE
  - Chemical Engineering 
description: This example introduces Corleone.
engines: ['julia']
julia:
  exeflags: ["--project=.."]
format: 
  html: default
  ipynb: default
---

```{julia}
using Corleone
using Corleone.ModelingToolkit
using Corleone.ModelingToolkit: t_nounits as t, D_nounits as D
using CairoMakie
using Corleone.Symbolics
```

```{julia}
function BrysonDenham(; name::Symbol)
    vars = @variables begin
      x(..) = 0., [tunable=false, bounds = (-Inf, 1. / 9.)]
      y(..) = 1., [tunable = false]
      u(..) = 0.0, [input = true]
    end 
    cons=[x(1) ~ 0.0, -y(1) - 1. ~ 0.0]
    eqs = [
        D(x(t)) ~ y(t)
        D(y(t)) ~ u(t)
    ]
    costs = [ 
        0.5 * Symbolics.Integral(t in (0., 1.)).((u(t))^2)
    ]
    return ODESystem(
        eqs, t, costs = costs, constraints = cons, consolidate = (x...) -> first(x)[1], name = name
    )    
end
```

```{julia}
oscillator = BrysonDenham(; name = :BrysonDenham)
```

```{julia}
u = ModelingToolkit.getvar(oscillator, :u, namespace = false)
control = DirectControlCallback(Num(u) => (; timepoints = collect(0.0:0.025:1.0)));
```

```{julia}
problem = OCProblemBuilder(oscillator, control, ShootingGrid(collect(LinRange(0., 1., 11))));
expandedproblem = problem()
```

```{julia}
using Optimization, OptimizationMOI, Ipopt
using OrdinaryDiffEqTsit5, SciMLSensitivity
```

```{julia}
optimization_problem = OptimizationProblem{true}(expandedproblem, AutoForwardDiff(), Tsit5())
```

```{julia}
optimization_solution = solve(optimization_problem, Ipopt.Optimizer(); max_iter = 100, tol = 1e-6, hessian_approximation="limited-memory");
```

## Solution 

```{julia}
#| code-fold: true
#| renderings: [light, dark]

using CairoMakie


function result_plot_bryson_denham(problem, u)
  f = Figure(title = "Bryson Denham Results")
  ax = Axis(f[1,1], ylabel = "x(t)")
  ax2 = Axis(f[2, 1], ylabel = "u(t)")
  sol = problem.f.f.predictor(u, saveat = 0.01)[1]
  for i in collect(1:1:10)
    plot!(sol[i], idxs = [:x, :y]) 
    plot!(sol[i], idxs = [:u])
  end
  linkxaxes!(ax, ax2)
  return f
end

# We want two outputs for the light and dark rendering. Hence we use display
update_theme!(theme_light());
f_light = result_plot_bryson_denham(optimization_problem, optimization_solution.u)
display(f_light)
update_theme!(theme_dark());
f_dark = result_plot_bryson_denham(optimization_problem, optimization_solution.u)

```

## Appendix

This document was rendered using Quarto CLI {{< version >}}.

```{julia}
#| code-fold: true
using Pkg

versioninfo()

Pkg.status() 
```

``{julia}
pred = optfun.f.f.predictor(sol.u, saveat = 0.01)[1]
f = plot(pred, idxs = [:x, :y, :u])
```