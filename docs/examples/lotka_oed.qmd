---
title: Lotka OED
author: Christoph Plate
date: last-modified
categories: 
  - ODE
  - OED 
description: This example introduces OED functionalities in Corleone.
engines: ['julia']
julia:
  exeflags: ["--project=.."]
format: 
  html: default
  ipynb: default
---

```{julia}
using Corleone
using Corleone.ModelingToolkit
using Corleone.ModelingToolkit: t_nounits as t, D_nounits as D
using CairoMakie
using Corleone.Symbolics
```

```{julia}
@variables begin
    x(..) = 0.5, [tunable=false]
    y(..) = 0.7, [tunable = false]
    u(..)=0.0, [input = true, bounds = (0., 1.)]
    h1(..)=0.0, [tunable=false, bounds=(0.,1.)]
    h2(..)=0.0, [tunable=false, bounds=(0.,1.)]
end

@parameters begin
    p1[1:2] = [1.0; 1.0], [tunable = false, uncertain=true]
    p2[1:2] = [0.4; 0.2], [tunable = false]
end


tspan = (0.0,12.0)
∫ = Symbolics.Integral(t in tspan)

@named lotka_volterra = System(
    [
        D(x(t)) ~ x(t) - p1[1] * x(t) * y(t) - p2[1] * x(t) * u(t),
        D(y(t)) ~ -y(t) + p1[2] * x(t) * y(t) - p2[2] * y(t) * u(t)
    ], t, [x(t), y(t), u(t)], [p1, p2];
    observed = [h1(t) ~ x(t); h2(t) ~ y(t)],
    constraints = [∫(h1(t)) ≲ 4.0; ∫(h2(t)) ≲ 4.0],
    consolidate=(x...)->first(x)[1]
)

```

In addition to normal optimal control problems, we have to specify observed variables and what we can measure. In this case, we assume we can measure the two states directly. Also, we add constraints that limit for how long we can measure, in this case a maximum of four time units for both sampling functions. The parameters for which we want to solve the OED problem have to be marked as uncertain.


```{julia}
N = 24
shooting_points = [0., 6.0, 12.0]
grid = ShootingGrid(shooting_points)

tpoints = collect(LinRange(0.,  12.0, N+1))[1:end-1]
controlmethod = DirectControlCallback(
    u(t) => (; timepoints=tpoints,
        defaults= collect(LinRange(0., 1., N))),
    h1(t) => (; timepoints=tpoints,
        defaults= ones(N)),
    h2(t) => (; timepoints=tpoints,
        defaults= ones(N)
    )
)
```

Internally, the two sampling functions are discretized. That's why we have to specify a control discretization for them as well. Also, now we have to call the OEDProblemBuilder that assembles the problem. Here, we have to specify a criterion that will be used as the objective function.

```{julia}
builder = OEDProblemBuilder(
    lotka_volterra, controlmethod, grid, ACriterion(tspan))
builder = builder()
```

```{julia}
using Optimization, OptimizationMOI, Ipopt
using OrdinaryDiffEqTsit5, SciMLSensitivity

optfun = OptimizationProblem{true}(builder, AutoForwardDiff(), Tsit5())
sol = solve(optfun, Ipopt.Optimizer(); max_iter = 50,
         tol = 1e-6, hessian_approximation="limited-memory")
```

## Solution 

```{julia}
#| code-fold: true
#| renderings: [light, dark]

using CairoMakie


plot_sol(x) = begin
    sol = optfun.f.f.predictor(x.u, saveat = 0.01)[1];
    f = Figure()
    plot!(Axis(f[1,1]), sol, idxs = [:x, :y, :u])
    plot!(Axis(f[1,2]), sol, idxs = [:G11, :G12, :G21, :G22])
    plot!(Axis(f[2,1]), sol, idxs = [:F11, :F12, :F22])
    plot!(Axis(f[2,2], xticks=0:1:12, limits=(nothing, (-0.02,1.02))), sol, idxs = [:w1, :w2])
    return f
end

# We want two outputs for the light and dark rendering. Hence we use display
update_theme!(theme_light());
f_light = plot_sol(sol)
display(f_light)
update_theme!(theme_dark());
f_dark = plot_sol(sol)

```

We can also do further analysis of the information gain.

```{julia}
using LinearAlgebra

IG = InformationGain(optfun.f.f.predictor, sol.u; saveat=0.025);
multiplier = sol.original.inner.mult_g

plot_ig(IG, mult) = begin
  f = Figure()
  ax = Axis(f[1,1], xticks=0:1:12)
  lines!(ax, IG.t, tr.(first.(IG.GIG)), label="Π1(t)", color=:black)
  lines!(ax, IG.t, tr.(last.(IG.GIG)), label="Π2(t)", color=:red)
  hlines!([-1; 1] .* mult[[5,17]], linestyle=:dash, color=[:black, :red])
  axislegend(ax, position=:lt)
  return f
end

update_theme!(theme_light());
f_light = plot_ig(IG, multiplier)
display(f_light)
update_theme!(theme_dark());
f_dark = plot_ig(IG, multiplier)


```


## Appendix

This document was rendered using Quarto CLI {{< version >}}.

```{julia}
#| code-fold: true
using Pkg

versioninfo()

Pkg.status() 
```
