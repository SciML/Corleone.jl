---
title: Egerstedt
author: Carl Julius Martensen
date: last-modified
categories: 
  - ODE
  - Chemical Engineering 
description: This example introduces Corleone.
engines: ['julia']
julia:
  exeflags: ["--project=.."]
format: 
  html: default
  ipynb: default
---

```{julia}
using Corleone
using Corleone.ModelingToolkit
using Corleone.ModelingToolkit: t_nounits as t, D_nounits as D
using CairoMakie
using Corleone.Symbolics
```

```{julia}
@variables begin
    x(..) = 0.5, [tunable=false]
    y(..) = 0.5, [tunable = false, bounds=(0.4, Inf)]
    u1(..) = 1/3, [input = true, bounds = (0, 1)]
    u2(..) = 1/3, [input = true, bounds = (0, 1)]
    u3(..) = 1/3, [input = true, bounds = (0, 1)]
end

∫ = Symbolics.Integral(t in (0., 1.))

@named egerstedt = System(
    [
        D(x(t)) ~ -x(t) * u1(t) + (x(t) + y(t)) * u2(t) + (x(t) - y(t)) * u3(t),
        D(y(t)) ~ (x(t) + 2 * y(t)) * u1(t) + (x(t) - 2 * y(t)) * u2(t) + (x(t) + y(t)) * u3(t)
    ], t, [x(t), y(t), u1(t), u2(t), u3(t)], [];
    constraints=reduce(vcat, [(u1(ti) + u2(ti) + u3(ti) - 1 ~ 0.0) for ti in collect(0.0:0.05:1.0)]),
    costs=Num[∫((x(t))^2 + (y(t))^2)],
    consolidate=(x...)->first(x)[1], # Hacky, IDK what this is at the moment
)
```

```{julia}
N = 20
shooting_points = collect(LinRange(0., 1., 11))

grid = ShootingGrid(shooting_points)
control = DirectControlCallback(
    u1(t) => (; timepoints=collect(LinRange(0.,  N / (N+1), N)),
        defaults= 0.3 * ones(N)
    ),
    u2(t) => (; timepoints=collect(LinRange(0.,  N / (N+1), N)),
    defaults= 0.3 * ones(N)
    ),
    u3(t) => (; timepoints=collect(LinRange(0.,  N / (N+1), N)),
    defaults= 0.3 * ones(N)
    )
)
```

```{julia}
problem = OCProblemBuilder(egerstedt, control, ShootingGrid(collect(LinRange(0., 1., 11))));
expandedproblem = problem()
```

```{julia}
using Optimization, OptimizationMOI, Ipopt
using OrdinaryDiffEqTsit5, SciMLSensitivity
```

```{julia}
optimization_problem = OptimizationProblem{true}(expandedproblem, AutoForwardDiff(), Tsit5())
```

```{julia}
optimization_solution = solve(optimization_problem, Ipopt.Optimizer(); max_iter = 100, tol = 1e-6, hessian_approximation="limited-memory");
```

## Solution 

```{julia}
#| code-fold: true
#| renderings: [light, dark]

using CairoMakie


function result_plot_egerstedt(problem, u)
  f = Figure(title = "Egerstedt Results")
  sol = problem.f.f.predictor(u, saveat = 0.01)[1]
  ax = Axis(f[1,1], ylabel = "x(t)")
  for i in collect(1:1:10)
    plot!(sol[i], idxs = [:x, :y]) 
  end
  ax2 = Axis(f[2, 1], ylabel = "u(t)")
  for i in collect(1:1:10) 
    plot!(sol[i], idxs = [:u1, :u2, :u3])
  end
  linkxaxes!(ax, ax2)
  return f
end

# We want two outputs for the light and dark rendering. Hence we use display
update_theme!(theme_light());
f_light = result_plot_egerstedt(optimization_problem, optimization_solution.u)
display(f_light)
update_theme!(theme_dark());
f_dark = result_plot_egerstedt(optimization_problem, optimization_solution.u)

```

## Appendix

This document was rendered using Quarto CLI {{< version >}}.

```{julia}
#| code-fold: true
using Pkg

versioninfo()

Pkg.status() 
```
